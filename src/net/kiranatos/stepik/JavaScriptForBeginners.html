<!DOCTYPE html>

<html>
    <head>
        <title>JavaScript для начинающих</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <h1>JavaScript для начинающих</h1>
        <p>(Антон Холин)</p>
        
        <script>
            
            function test01(a) {
                var x="rrrr";
                for (var i = 0; i < a; i++) {
                    console.log(i + ' ');
                }
                return x;
            }
            document.writeln("Test1");
            document.writeln(test01(20));
            document.writeln("Test2");
            
            function testFactorial02(a) {
                var x=1;                
                for (var i = 1; i <= a; i++) {
                    x = x * i;                    
                }
                return x;
            }
            document.writeln("<p>-----------120-------------</p>");
            document.writeln("<p>" + testFactorial02(4) + "</p>");
            
            
            function testWhile(a) {
                var x=0;
                // Тут нужно написать решение
                var i = 1;
                while (i<=a){
                    if (i%2==0) {
                        x = x + i;
                    }
                    i=i+1;
                }
                return x;
            }
            
            document.writeln("<p>-----------testWhile(a)-------------</p>");
            document.writeln("<p>" + testWhile(10) + "</p>");
            
            document.writeln("<p>-----------testFunction-------------</p>");
            
            var printText1 = function(a) { document.write("1" + a);};
            
            var printText2 =  function(a) {document.write(a);} ("2: Hello World!");
            var printText3 = (function(a) {document.write(a);} ("3: Hello World!"));

            
            var myFunction = function(a) {document.write(a); } ;            
            function Function(a) { document.write(a); };
            function myFunction() { }; 
            
            document.writeln("<p>-----------lenghtOfString-------------</p>");
            function testStr(a, b) {
                var str = a + b;
                return str.length;
            }
            document.writeln(testStr(123456, 7890));
            document.writeln("<p>-</p>");
            document.writeln(testStr('123456', '7890'));
            document.writeln("<p>-</p>");
            
            document.writeln("<p>-----------Рекурсия-------------</p>");
            function my_function(n) {
                if (n===1) return "1";
                else if (n<=0) return "";
                else {
                   return my_function(n-1)+ " " +n;
                }                
            }
            document.writeln("<p>Test 10:</p>" + my_function(10));
            document.writeln("<p>Test 5:</p>" + my_function(5));
            document.writeln("<p>Test 1:</p>" + my_function(1));
            document.writeln("<p>Test 0:</p>" + my_function(0));
            document.writeln("<p>Test -10:</p>" + my_function(-10));
        </script> 
        
        <h1>2 Стандартные объекты</h1>
        <p>2.3 Строки</p>
        <pre>
В этом задании в нашу функцию testStr первым параметром передается строка
(переменная str), а вторым - число (переменная n) . Вам нужно вернуть из 
функции символ строки , порядковый номер которого указан в переданном в 
функцию числе.

Подсказка: порядковый номер не равен индексу символа в строке. Если есть 
сомнения - перечитайте предыдущие шаги.

Sample Input:
Ithardlycousinmealways
19

Sample Output:
w
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testStr001(str, n) {
                return str.charAt(n-1);
            }
            document.writeln(testStr001("Ithardlycousinmealways",19));            
        </script>
        <pre> В этом задании в нашу функцию testStr передаются две строки. 
Вам нужно вернуть из функции строку, которая будет включать в себя обе этих 
строки, преобразовав в первой строке все буквы в заглавные, а во второй - 
в строчные.

Sample Input:   Hello World!
Sample Output:  HELLOworld!
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testStr002(a, b) {
                return a.toUpperCase().concat(b.toLowerCase());
            }
            document.writeln(testStr002("Hello", "World!"));            
        </script>
        <h2>***************************************************</h2>
        <pre>В этом задании в нашу функцию testStr передаются две строки. 
Вам нужно вернуть индекс позиции, с которой начинается вхождение второй строки в первую.
Sample Input:
                This is a test string
                test
Sample Output:  10
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testStr003(a, b) {
                return a.indexOf(b, 0);
            }
            document.writeln(testStr003("This is a test string", "test"));            
        </script>
        <h2>***************************************************</h2>
        <h1>2.4 Массивы</h1>
        <pre> В этом задании в нашу функцию testArray передаются два массива 
случайной длины заполненные случайными числами. Вам нужно сосчитать сумму всех 
элементов обоих массивов и возвратить ее из функции.
Sample Input:   [8, 1, 1, 7, 4, 0]  [5, 8, 5, 4, 8]
Sample Output:  51
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testArray004(a, b) {
                var sum = 0;
                for (var i = 0; i < a.length; i++) {
                    sum = sum + a[i];
                }
                for (var i = 0; i < b.length; i++) {
                    sum = sum + b[i];
                }
                return sum;
            }
            document.writeln(testArray004(new Array(8, 1, 1, 7, 4, 0), new Array(5, 8, 5, 4, 8)));
        </script>
        <h2>***************************************************</h2>
        <pre>В этом задании в нашу функцию testArray передаются две строки 
случайной длины и содержания. Вам нужно составить из символов этих строк 
один массив (каждый символ строки становится отдельным элементом массива), 
затем добавить первым элементом  массива текстовое значение "Иванов", 
и вернуть из функции все элементы в обратном порядке, преобразовав в строку. 
Обратите внимание, что в обратном порядке нужно переставить элементы внутри 
массива, а данные внутри элементов инвертировать не нужно!
        Sample Input:   4326 297515
        Sample Output:  5157926234Иванов
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testArray005(a, b) {
                var array = a.split('').concat(b.split(''));
                array.unshift("Иванов");
                var str = array.reverse().join("");                
                return str;
            }
            document.writeln(testArray005("4326", "297515"));
        </script>
        <h2>***************************************************</h2>
        <h1>2.5 Дата и время</h1>
        <script>            
            document.writeln("<p>Тестирование даты</p>");
            var d01 = new Date();
            document.writeln(d01);
            document.writeln("<p></p>" + d01.getDay());
            document.writeln("<p></p>" + d01.getYear());
            document.writeln("<p></p>" + d01.getFullYear());
            d01.getDay();
        </script>
        <pre>В этом задании в нашу функцию testDateTime передаются две строки 
вида "03 November 2017 04:17". Вам нужно превратить строки в даты, сравнить их. 
Для той, что больше получить день недели и вернуть его из функции.
Название дня недели должно быть по-русски, с большой буквы, например: "Понедельник".

Sample Input 1:
        15 January 1909 11:56
        01 July 1909 07:56
Sample Output 1:
        Четверг

Sample Input 2:
        13 March 1909 03:15
        21 March 1909 23:10
Sample Output 2:
        Воскресенье
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testDateTime006(a, b) {                                
                var aDate = new Date();
                aDate.setTime(Date.parse(a));
                var bDate = new Date();
                bDate.setTime(Date.parse(b));
                var k;
                if (aDate>bDate) k = aDate.getDay();
                else k = bDate.getDay();
                
                switch(k) {
                    case 0: return "Воскресенье";
                    case 1: return "Понедельник";
                    case 2: return "Вторник";
                    case 3: return "Среда";
                    case 4: return "Четверг";
                    case 5: return "Пятница";
                    case 6: return "Суббота";                        
                }
            }
            document.writeln(testDateTime006("15 January 1909 11:56",   "01 July 1909 07:56"));
            document.writeln(testDateTime006("13 March 1909 03:15",     "21 March 1909 23:10"));
            document.writeln(testDateTime006("11 August 2017 03:15",     "12 August 2017 03:15"));
        </script>
        <h2>***************************************************</h2>
        <h1>2.6 Математические функции</h1>
        <pre>В этом задании в нашу функцию передается угол в градусах. 
Вам нужно вернуть из функции значение его синуса. Не забывайте, что 
тригонометрические функции в JavaScript принимают аргументы только в радианах!

Sample Input:   348
Sample Output:  -0.20791169081775987
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testMath007(a) {    
                return Math.sin( (a * Math.PI) / 180 );                
            }
            document.writeln(testMath007(348));
        </script>
        <h2>***************************************************</h2>
        <pre>А тут вам нужно вычислить и вернуть из функции площадь треугольника. 
Передаваемые в функцию аргументы "a" и "b" - это длины сторон, а "c" - это угол 
между ними в градусах.

Sample Input:   2 10 16
Sample Output:  2.7563735581699915
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testMath008(a, b, c) {
                // S = 1/2*a*b*sin(c)
                return 0.5 * a * b * Math.sin( (c * Math.PI) / 180 );
            }
            document.writeln(testMath008(2, 10, 16));
        </script>
        <h2>***************************************************</h2>
        <pre>В этом задании в нашу процедуру передаются 4 числа. Вам необходимо 
вычислить результат деления большего из этих чисел на меньшее, и округлив до 
ближайшего меньшего целого вернуть из функции.

Sample Input:   1 4 8 8
Sample Output:  8
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testMath009(a, b, c, d) {
                // Тут нужно написать решение
                var min = Math.min(a,b,c,d);
                var max = Math.max(a,b,c,d);
                return Math.floor(max/min);
            }
            document.writeln(testMath009(1, 4, 8, 8));
        </script>
        <h2>***************************************************</h2>
        <pre>В этом задании вам необходимо выполнить возведение переменной a 
в степень b и возврат значения из функции.

Sample Input:   5 1
Sample Output:  5
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testMath010(a, b) {
                return Math.pow(a, b);
            }
            document.writeln("<p>" + testMath010(5, 1) + "</p>");
            document.writeln("<p>" + testMath010(5, 5) + "</p>");
            document.writeln("<p>" + testMath010(2, 8) + "</p>");
        </script>
        <h2>***************************************************</h2>
        <h1>3.2 Введение в регулярные выражения</h1>
        <p>/hello$/ - соответствует строкам, которые ЗАКАНЧИВАЮТСЯ на слово "hello". Это обеспечивает метасимвол "$", обозначающий конец строки.</p>        
        <p>Пример создания регулярного выражения:</p>
        <p>var myPattern = /hello$/; </p>
        <p>var myPattern = new RegExp("hello$");</p>
        <pre>
                <strong>\0</strong> - Символ NUL (Соответствует \u0000 в Unicode)
                <strong>\t</strong> - Табуляция (\u0009)
                <strong>\n</strong> - Перевод строки (\u000A)
                <strong>\v</strong> - Вертикальная табуляция (\u000B)
                <strong>\f</strong> - Перевод страницы (\u000C)
                <strong>\r</strong> - Возврат каретки (\u000D)
                <strong>\xnn</strong> - Символ из набора Latin, задаваемый шестнадцатиричным номером nn
                <strong>\unnnn</strong> - Символ Unicode,  задаваемый шестнадцатиричным номером nnnn
                <strong>\cX</strong> - Управляющий символ "Х", например \сJ эквивалентна \n
        </pre>
        <p>/\\/ -  для нахождения символа обратного слэша</p>
        <p>/[0123456789]/ - соответствует любой цифре</p>
        <p>Отдельные символы могут быть объединены в классы - /[ ]/</p>
        <p>/[^0123456789]/ - Любому символу, КРОМЕ тех, которые указаны в скобках - класс с отрицанием. Любому символу КРОМЕ цифр.</p>
        <p>/[0-9]/ - Все цифры. Можно задавать диапазон с помощью знака дефиса "-"</p>
     
        <pre>Для некоторых классов из наборов символов которые часто используются, имеют специальные обозначения:
                [...] - любой из символов, указанных в скобках
                [^...] - любой кроме символов, указанных в скобках
                . (точка) - любой символ кроме перевода строки или другого разделителя строки
                \w - эквивалентно [a-zA-Z0-9_] (Любой текстовый символ ASCII)
                \W - эквивалентно [^a-zA-Z0-9_] (Любой символ кроме текстовых символов ASCII)
                \s - любой пробельный символ из Unicode
                \S - любой НЕпробельный символ из Unicode
                \d - эквивалентно [0-9] (любые цифры ASCII)
                \D - эквивалентно [^0-9] (все символы кроме цифр ASCII)
                [\b] - обозначение символа "забой"
        </pre>
        <p>/[\w\s]/ - соответствует любому пробельному символу или символу ASCII - букве или цифре.</p>
        <a href="https://regex101.com/">regex101.com</a>
        <script>
            document.writeln("<p>------------------------</p>");
            function testRegular01(a, b) {  
                document.write("<p>/" +  a + "/ для строки \"" + b + "\" : ");                
                return (new RegExp(a)).test(b) + "</p>";
            }
            document.writeln(testRegular01("qwerty", "123qwerty456"));
            document.writeln(testRegular01("\\W", "qwerty"));
            document.writeln(testRegular01("\\w", "qwerty"));
            document.writeln(testRegular01("[7-9]", "123qwerty456"));
            document.writeln(testRegular01("\\d", "123qwerty456"));
            document.writeln(testRegular01("qwerty", "qwerty"));
            document.writeln(testRegular01("[^qwerty]", "123qwerty456"));
            document.writeln(testRegular01("[^qwerty]", "qwerty"));
        </script>
        <h4>-------------------------------------------------</h4>
        <pre>
{ } - квантификацией
/\d{4}/ - числo, состоящеe из 4-х цифр.

{n} - обозначает ровно n экземпляров шаблона
{n,} - обозначает n или больше экземпляров шаблона  
{n,m} -  обозначает не менее n и не более m экземпляров шаблона
? -  обозначает ноль или один экземпляр шаблона (эквивалентно выражению {0,1} )
+ -  обозначает 1 или более экземпляров шаблона (эквивалентно выражению {1,} )
* -  обозначает ноль или более экземпляров шаблона (эквивалентно выражению {0,} ) 

/х{1,}/ - примеренное к строке "ххх" будет соответствовать максимальному количеству соответствий, т.е. всем трем буквам "х", встреченным в строке. Это называется "жадным" повторением. ("жадной" квантификацией).

/х{1,}?/  - "нежадную", или "ленивую" квантификацию. Для этого после управляющей комбинации повторений ставится символ "?". Таким образом выражение
будет соответствовать только первому соответствию, т.е. только первой букве "х" в строке.
        </pre>
        <h4>-------------------------------------------------</h4>
        <pre>
Альтернативы
/ma|pa|da/ - будет соответствовать либо строке "ma" либо строке "pa" либо строке "da".

/\d{2}|[a-z]{2}|[A-Z]{2}/ - cоответствует либо двум цифрам либо двум строчным буквам либо двум заглавным буквам

Необходимо обратить внимание, что альтернативы обрабатываются слева направо до первого соответствия.
        </pre>
        <h4>-------------------------------------------------</h4>
        <pre>
Группировка обозначается заключением подшаблона в круглые скобки ( ). При этом элементы, используемые совместно со специальными символами, например |, +, *, ? и другие, будут рассматриваться как одно целое.
/regular(expression)?/ - будет соответствовать слову "regular" за которым следует необязательное слово "expression".
        </pre>
        <h4>-------------------------------------------------</h4>
        <pre>
якорные выражения.
^ - соответствует началу строки при многострочном поиске или началу строкового выражения
$ - соответствует концу строки при многострочном поиске или концу строкового выражения
\b - соответствует границе слова, т.е. позиции между текстовым (aA-zZ) и не-текстовым символом, либо между текстовым         символом и началом или концом строки.
\B - Соответствует позиции, не являющейся границей слов.
(?=p) - Позитивная опережающая проверка на последующие символы - убеждается в том, что последующие символы соответствуют шаблону "р" но не включает их в результат поиска.
(?!p) - Негативная опережающая проверка на последующие символы - требует чтобы последующие символы НЕ соответствовали шаблону "р".
        </pre>
        <h4>-------------------------------------------------</h4>
        <pre>
флаги
Флаги задают глобальные правила для всего шаблона и указываются не внутри 
символов слэша, в которые заключен шаблон, а ПОСЛЕ них.
JavaScript поддерживает три варианта флагов:
i - указывает на то, что поиск по шаблону должен быть не чувствительным к регистру
g - указывает что поиск должен быть глобальным, т.е. должны быть найдены ВСЕ 
соответствия в строке
m - указывает на то, что поиск должен производиться в многострочном режиме.

/([\d]{2})\.([\d]{2})\.([\d]{4})/ - Дата в формате DD.MM.YYYY
/^\d{6}$/ - Почтовый индекс РФ
/^([0-9a-z]([0-9a-z\-])*[0-9a-z]\.)+[a-z]{2,4}$/i - Доменное имя
/[A-Z0-9._%+-]+@[A-Z0-9-]+.+.[A-Z]{2,4}/igm - Адрес электронной почты
/\#([a-fA-F]|[0-9]){3,6}/ - Код цвета в шестнадцатеричном формате
/-?\d{1,3}\.\d+/ - Широта или долгота
/^([0-1]\d|2[0-3])(:[0-5]\d){2}$/ - Время в формате HH:MM:SS
        </pre>
        <h4>-------------------------------------------------</h4>
        <h3>Mетод search()</h3>
        <pre>В качестве аргумента мы передаем ему регулярное выражение, 
а он нам в ответ возвращает номер позиции, с которой найдено соответствие 
шаблону, либо "-1" если соответствие не найдено.
<strong>
var myString = "This is just test string";
result = myString.search(/is/);
</strong>
В указанном примере в переменной result окажется число 2 (отсчет позиций начинается с 0).

Два важных момента:
1. Метод search() не поддерживает глобальный поиск и флаг <strong>g</strong> в 
составе регулярного выражения будет игнорирован.
2.  Если аргумент не является регулярным выражением, то он будет преобразован 
в него передачей конструктору RegExp.
        </pre>
        
        <h3>Mетод replace()</h3>
        <pre>В качестве аргументов принимает регулярное выражение и строку замены.
<strong>
var myString = "This is just test string";
result = myString.replace(/is/,"us");
</strong>
в переменной result окажется строка  "<strong>Thus is just test string</strong>".
- поддерживает глобальный поиск и при использовании флага "g" поменяет все найденные соответствия.
<strong>
var myString = "This is just test string";
result = myString.replace(/is/g,"us");
</strong>
В переменной result окажется строка  "Thus us just test string".

Еще необходимо также отметить, что в качестве второго аргумента метода replace() 
может использоваться функция, в этом случае мы получим возможность динамического изменения строки замены.

Если в качестве первого аргумента окажется не регулярное выражение, то он будет
также как и у метода search() преобразован в регулярное выражение с помощью 
конструктора RegExp. А если второй аргумент вовсе забыть указать, то будет 
произведена замена всех найденных совпадений на Undefined.</pre>
    
        <h3>Mетод match()</h3>
        <pre>Принимает в качестве аргумента регулярное выражение (или преобразовывает в него),
 а в качестве результата возвращает массив всех найденных соответствий.
<strong>
var myString = "У дедушки в деревне было 12 яблонь, 5 кустов смородины, 10 кур и 33 коровы";
result = myString.match(/\d{2}/g);
</strong>
В данном примере мы записали в регулярное выражение обозначение цифры "\d", 
указали что ищем её двойное повторение "{2}" и включили флаг глобального поиска "g". 
В результате в переменной result окажется массив [<strong>"12", "10", "33"</strong>].

Однако если флаг глобального поиска не будет указан, то в массив попадет только 
первое совпадение, оно запишется нулевым элементом. Остальными элементами массива 
будут подстроки, соответствующие всем подвыражениям, если таковые имеются.
        [<strong>0: "12", index: 25, input: "У дедушки в деревне было 12 яблонь, 5 кустов смородины, 10 кур и 33 коровы"</strong>]</pre>
 
        <h3>Mетод split()</h3>
        <pre>Он разбивает строку на массив подстрок, используя в качестве разделителя содержимое аргумента, которое в том числе может быть и регулярным выражением. Например, использовав в качестве разделителя два слэша можно отделить в веб-адресе протокол от собственно наименования сайта:

var myString = "http://www.example.com/download/pictures";
result = myString.split(/\/{2}/g);


Результатом данного выражения станет массив из двух элементов: "http:" и  "www.example.com/download/pictures"

Таким же образом, например, можно разбить на массив строку состоящую из цифр:

var myString = "1234567890987654321"
result = myString.split(/\B/g);


Используя в качестве разделителя определение символа, не являющегося границей слова (странное решение, но почему нет) получим в переменной result массив  [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1].</pre>
        <h2>Oбъект RegExp</h2>
        <pre>Конструктор RegExp может принимать на вход строку, содержимое которой будет преобразовано в регулярное выражение.
<strong>var myPattern = new RegExp("q$");</strong> // Создаем шаблон, находящий букву "q" в конце строки
Также в конструктор можно передать второй, необязательный аргумент, в котором можно указать флаги:
<strong>var myPattern = new RegExp("q$","g");</strong> // Создаем такой же шаблон, но добавляем флаг глобального поиска
<strong>"\"</strong> - экранировать!
        </pre><h4>Свойства объекта RegExp:</h4><pre>
<strong>source</strong> - собственно текст регулярного выражения
<strong>ignoreCase</strong> - логическое значение обозначающее наличие флага "i", доступно только для чтения
<strong>global</strong> - логическое значение обозначающее наличие флага "g",  доступно только для чтения
<strong>multiline</strong> - логическое значение обозначающее наличие флага "m",  доступно только для чтения
<strong>lastIndex</strong> - счетчик, указывающий, с какой позиции в строке начинать поиск
        </pre><h4>Методы объекта RegExp:</h4><pre>
<strong>exec(text)</strong> - выполнение поиска в строке, указанной в качестве параметра, возвращает массив найденных соответствий.
<strong>test(text)</strong> - проверка соответствия регулярному выражению, возвращает <strong>true\false.</strong>
<u>Метод exec()</u>> выполняет регулярное выражение по отношению к строке-аргументу, 
результатом его работы является массив, в который попадают соответствия. 
Если соответствий не найдено, то результатом будет null. А если соответствие есть, 
то оно попадает в массив нулевым элементом, при этом свойство lastIndex объекта 
сместится на позицию, следующую непосредственно за найденной подстрокой:
<strong>
var myString = "This is just a test text";  // Задаем строку для поиска
var myPattern = /te|is/g;                   // Задаем шаблон - либо "te" либо "is"
result = myPattern.exec(myString);
//result будет равен "is" - первому совпадению шаблона, свойство lastIndex примет значение 4
result = myPattern.exec(myString); //result == "is" - второму совпадению шаблона, lastIndex == 7
result = myPattern.exec(myString); //result == "te" - третьему совпадению шаблона, lastIndex == 17
result = myPattern.exec(myString); //result == "te" - четвертому совпадению шаблона, lastIndex == 22
</strong>
В этом примере мы четыре раза подряд вызываем метод exec(), каждый раз он сдвигает 
указатель начала поиска на позицию, следующую за найденным совпадением и присваивает переменной result найденное совпадение.
        
<u>Метод test()</u> выполняет регулярное выражение по отношению к строке-аргументу, 
результатом его работы является логическое значение - true если совпадение есть, и false если нет. 
Свойство lastIndex объекта также как и у метода exec() сместится на позицию, следующую непосредственно за найденной подстрокой.

<u>Важный момент!</u> Если совпадение не найдено, то lastIndex будет смещен на позицию 0 и поиск можно будет начинать сначала:
<strong>var myString = "This is just a test text";</strong>  // Задаем строку для поиска
<strong>var myPattern = /te|is/g;</strong>                   // Задаем шаблон - либо "te" либо "is"
<strong>result = myPattern.test(myString);</strong> // result будет равен true, поскольку будет найдено первое совпадение, свойство lastIndex примет значение 4
<strong>result = myPattern.test(myString);</strong> // result == true, lastIndex == 7
<strong>result = myPattern.test(myString);</strong> // result == true, lastIndex == 17
<strong>result = myPattern.test(myString);</strong> // result == true, lastIndex == 22
<strong>result = myPattern.test(myString);</strong> // result == false, lastIndex == 0
В этом примере мы четыре раза подряд вызываем метод test(), каждый раз он сдвигает указатель 
начала поиска на позицию, следующую за найденным совпадением и присваивает 
переменной result булево значение - true если совпадение найдено и false - если нет. 
В последнем запуске совпадение не найдено, поэтому указатель lastIndex получает значение 0.</pre>           
        
        <h2>***************************************************</h2>
        <pre>В этом задании в нашу функцию testRegExp первым параметром передается 
случайная строка(переменная s), а вторым - случайная подстрока(переменная sub_s), 
которую нужно использовать в качестве шаблона регулярного выражения. 
Вам нужно вернуть из функции строку, в которой будут перечислены через запятую 
все совпадения шаблона с первой строкой.
        Sample Input 1:     Andsirdaarrevarariarewbutovearrmararan
                            ar
        Sample Output 1:    ar,ar,ar,ar,ar,ar,ar

        Sample Input 2:     Extremitiyasiifbrieakfaistagreement
                            i
        Sample Output 2:    i,i,i,i,i,i
        </pre>
        <script>            
            document.writeln("<p>------------------------</p>");
            function testRegExp(s, sub_s) {
                var str = "";
                var myPattern = new RegExp(sub_s, "g");
                var m = s.match(myPattern);
                if (!(m==null)) {
                    str = m[0];
                    if (m.length > 1) {          
                        for (var i=1; i<m.length; i++ ) {                            
                            str = str + "," + m[i];
                        }
                    }
                }
                return str;
            }
            document.writeln("<p>" + testRegExp("Andsirdaarrevarariarewbutovearrmararan", "ar") + "</p>");
            document.writeln("<p>" + testRegExp("Extremitiyasiifbrieakfaistagreement", "i") + "</p>");
        </script>        
        <h2>***************************************************</h2>
        <h1>3.4 Замыкания</h1> 
        
        
    </body>
</html>
